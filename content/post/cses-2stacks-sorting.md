---
title: "CSE 2402: Two Stacks Sorting"
date: 2022-12-17
draft: false
---

### Problem Statement

Given a permutation `p` of `[1..n]`, you are tasked with finding a sequence to sort the permutation using two stacks, with possible interleaving push/pop operations. You should also determine if it's impossible to sort the permutation.

**Constraint:** `n ~ 2e5`

```cpp
Example: [5 2 4 1 6 3]
Sequence: 
    push 1 [5]        []
    push 2 [5]        [2]
    push 1 [5 4]      [2]
    push 1 [5 4 1]    [2]
    pop  1 [5 4]      [2]
    pop  2 [5 4]      []
    push 2 [5 4]      [6]
    ...
```

### Hint

According to [this paper](https://dl.acm.org/doi/10.1145/321694.321704) referencing [this book](https://www.amazon.com/Theory-Machines-Computations-Zvi-Kohavi/dp/0124177506), the problem of `m`-stack sorting in gerneral is equivalent to the `m`-coloring problem of the graph generated by the rule:

```cpp
For every index i,j,k which match the pattern 231 
(i.e. i < j < k and p[k] < p[i] < p[j]), 
there is an egde between p[i] and p[j]
```
However, recreate the whole graph is infeasible under the constraint; an 'mountain' permutation's graph can have as much as $O(n^2)$.
Instead we are going to build the connected components and recolor them on the fly. An important observation:

```
For every index i, we need 2 information:
Of all element on the right, what is the minimum? (This contributes to the 1 in the pattern)
Of all connected components that we build on the left, which ones has an element that is larger than the previous minimum?
```

Luckily, both of those question can be answered by maintain the priority queue for each component.

The only part left is coloring: If any component has both black and white vertices that satisfy the second condition above, then we cannot 2-coloring the graph. Otherwise, we can merge it with the current component, and recolor if need. The final trick under the sleeve is small-to-large merging to achieve the $O(n \log n)$ runtime.

### Impl

DIY